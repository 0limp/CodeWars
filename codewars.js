// # =============================================================================================================================================
// Дан массив целых чисел. Возвращает массив, где первый элемент — это количество положительных чисел, 
// а второй элемент — сумма отрицательных чисел. 0 не является ни положительным, ни отрицательным. 
// Если входные данные представляют собой пустой массив или имеют значение NULL, верните пустой массив.

// Пример Для ввода [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14, -15] вы должны вернуть [10, -65]
// Пример Для ввода [0, 2, 3, 0, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14] вы должны вернуть [8, -50]

function countPositivesSumNegatives(input) {
    if (!Array.isArray(input) || input.length <= 0) {
        return []
    } else {
        const positiveArr = [];
        const negativeArr = [];
        for (let i = 0; i < input.length; i++) {
            if (input[i] === 0 && input.length === 1) {
                return []
            } else {
                if (input[i] > 0) {
                    positiveArr.push(input[i])
                } else if (input[i] < 0) {
                    negativeArr.push(input[i])
                }
            }
        }
        const a = positiveArr.filter(e => e > 0)
        let b = 0;
        for (let k = 0; k < negativeArr.length; k++) {
            b += negativeArr[k]
        }
        return [a.length, b];
    }
}

// console.log(countPositivesSumNegatives([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14, -15]));
// console.log(countPositivesSumNegatives([0, 2, 3, 0, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14]));
// console.log(countPositivesSumNegatives([]));

// # =============================================================================================================================================
// После тяжелого квартала в офисе вы решаете немного отдохнуть в отпуске. Итак, вы забронируете рейс для себя и своей девушки
// и постараетесь оставить позади весь этот беспорядок. Вам понадобится арендованный автомобиль, чтобы передвигаться во время отпуска.
// Менеджер по прокату автомобилей делает вам несколько выгодных предложений. Каждый день аренды автомобиля стоит 40 долларов. Если вы
// арендуете автомобиль на 7 и более дней, вы получите скидку 50 долларов США. Альтернативно, если вы арендуете автомобиль на 3 или более
// дней, вы получите скидку 20 долларов США. Напишите код, который выдает общую сумму за разные дни(d).
const rentalCarCost = d => {
    return (d >= 7) ? (d * 40) - 50 : (d >= 3) ? (d * 40) - 20 : d * 40;
}

// # =============================================================================================================================================
// Напишите функцию для разделения строки и преобразования ее в массив слов.
function stringToArray(string) {
    return string.split(' ')
}
// console.log(stringToArray("Robin Singh"));
// console.log(stringToArray("I love arrays they are my favorite"));

// # =============================================================================================================================================
// Первое столетие охватывает от 1 года до 100 года включительно, второе столетие — от 101 года до 200 года включительно и т. д.
// Учитывая год, верните столетие, в котором он находится.
// 1705 --> 18
// 1900 --> 19
// 1601 --> 17
// 2000 --> 20

// мое решение
function century(year) {
    if (year % 100 === 0) {
        return year / 100
    } else {
        return Math.ceil(year / 100)
    }
}

// короткое решение у других
// function century(year) {
//     return Math.ceil(year / 100)
// }

// console.log(century(1705));
// console.log(century(1900));
// console.log(century(1601));
// console.log(century(2000));
// console.log(century(89));
// console.log(century(362860));


// # =============================================================================================================================================
// Напишите функцию findNeedle(), которая принимает массив, полный мусора, но содержащий один елемент 'needle' «игла».
// После того, как ваша функция найдет 'needle', она должна вернуть сообщение (в виде строки), в котором говорится: found the needle at position
// плюс индекс, на котором найдена 'needle', поэтому: Пример (Ввод -> Выход)

// Пример (Ввод -> Выход)
// ["hay", "junk", "hay", "hay", "moreJunk", "needle", "randomJunk"] --> "found the needle at position 5" 

function findNeedle(haystack) {
    return `found the needle at position ${haystack.indexOf('needle')}`
}

// console.log(findNeedle(["hay", "junk", "hay", "hay", "moreJunk", "needle", "randomJunk"]));
// console.log(findNeedle(['3', '123124234', undefined, 'needle', 'world', 'hay', 2, '3', true, false]))
// console.log(findNeedle(['283497238987234', 'a dog', 'a cat', 'some random junk', 'a piece of hay', 'needle', 'something somebody lost a while ago']))
// console.log(findNeedle([1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 5, 4, 3, 4, 5, 6, 67, 5, 5, 3, 3, 4, 2, 34, 234, 23, 4, 234, 324, 324, 'needle', 1, 2, 3, 4, 5, 5, 6, 5, 4, 32, 3, 45, 54]))



// # =============================================================================================================================================
// Напишите функцию, которая вычисляет среднее значение чисел в заданном списке. 
// Примечание. Пустые массивы должны возвращать 0.

// искал решение в инете
// было не очень понятно как найти среднее число в массиве
function findAverage(array) {
    if (array.length === 0) {
        return 0;
    } else {
        const sum = array.reduce((a, b) => a + b)
        return sum / array.length;
    }
}

// Оказывается все гораздо проще.
// СРЕДНЕЕ АРИФМЕТИЧЕСКОЕ
// Определение и способы нахождения среднего арифметического учащиеся изучают в 5 классе, но это важно и во время сдачи экзаменов в старших классах.

// Например, ученик получил за четверть следующие баллы: 5, 4, 5, 3, 3, 5, 4, 5, 4, 5.
// Чтобы посчитать средний балл, нужно сложить все оценки, а затем разделить на их количество (10).
// 5 + 4 + 5 + 3 + 3 + 5 + 4 + 5 + 4 + 5 = 43
// 43 : 10 = 4,3

//!             Формула
//!
//?         a + b + c + d       // складываем все числа
//?         _____________       // делим
//?               4             // на количество чисел


// console.log(findAverage([1, 1, 1]))         // ==> 1
// console.log(findAverage([1, 2, 3]))         // ==> 2
// console.log(findAverage([1, 2, 3, 4]))      // ==>  2.5



// # =============================================================================================================================================
// Суть этой ката заключается в умножении заданного числа на восемь, если оно четное, и на девять в противном случае.
function simpleMultiplication(number) {
    if (number % 2 === 0) {
        return number * 8
    } else {
        return number * 9
    }
}
// console.log(simpleMultiplication(2));
// console.log(simpleMultiplication(1));
// console.log(simpleMultiplication(8));
// console.log(simpleMultiplication(4));
// console.log(simpleMultiplication(5));


// # =============================================================================================================================================
// Если не можешь заснуть, просто посчитай овец!! 
// Задача: Учитывая неотрицательное целое число, например 3, верните строку с бормотанием: «1 овца...2 овцы...3 овцы...». 
// Ввод всегда будет действительным, т. е. без отрицательных целых чисел.  
var countSheep = function (num) {
    let str = '';
    if (num < 0) {
        return '';
    } else if (num === 0) {
        return '';
    } else {
        let sheep = 'sheep...'
        for (let i = 0; i < num; i++) {
            str += `${i + 1} ${sheep}`
        }
        return str
    }
}
// console.log(countSheep(1));
// console.log(countSheep(7));
// console.log(countSheep(3));
// console.log(countSheep(10));

// # =============================================================================================================================================
// В этом ката вы создадите функцию, которая принимает список неотрицательных целых чисел и строк и возвращает новый список с отфильтрованными строками.
// Пример:
// - filter_list([1,2,'a','b']) == [1,2]
// - filter_list([1,'a','b',0,15]) == [1,0,15]
// - filter_list([1,2,'aasf','1','123',123]) == [1,2,123]

function filter_list(l) {
    return l.filter(e => typeof e === 'number')
}

// console.log(filter_list([1,2,'a','b']));
// console.log(filter_list([1,'a','b',0,15]));
// console.log(filter_list([1,2,'aasf','1','123',123]));
// ! Honor:44

// # =============================================================================================================================================
// Реализуйте функцию, которая преобразует данное логическое значение в его строковое представление. Примечание. Будут предоставлены
// только действительные входные данные.
// Примечание. Будут предоставлены только действительные входные данные.

function booleanToString(b) {
    return b.toString();
}

// console.log(booleanToString(true));
// console.log(booleanToString(false));
// ! Honor:46

// # =============================================================================================================================================
// Суммирование Напишите программу, которая находит сумму всех чисел от 1 до num.
// Число всегда будет положительным целым числом, большим 0. 
// Например (Ввод -> Выход):
// 2 -> 3 (1 + 2)
// 8 -> 36 (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8)

var summation = function (num) {
    const arr = []
    for (let i = 1; i <= num; i++) {
        arr.push(i)
    }
    const sum = arr.reduce((a, i) => a + i)
    return sum
}

// console.log(summation(1));
// console.log(summation(2));
// console.log(summation(8));
// ! Honor:48

// # =============================================================================================================================================
// Описание:
// Нам нужна функция, которая может преобразовать строку в число. Какие способы достижения этой цели вы знаете?

// Примечание. Не волнуйтесь, все входные данные будут строками, и каждая строка является совершенно допустимым представлением целого числа.
// Примеры:
// "1234" --> 1234
// "605"  --> 605
// "1405" --> 1405
// "-7" --> -7

const stringToNumber = function (str) {
    return Number(str);
}
// console.log(stringToNumber("1234"))
// console.log(stringToNumber("605"))
// console.log(stringToNumber("1405"))
// console.log(stringToNumber("-7"))

// # =============================================================================================================================================
// Ваша команда пишет новый модный текстовый редактор, и вам было поручено реализовать нумерацию строк.
// Напишите функцию, которая принимает список строк и возвращает каждую строку, перед которой стоит правильный номер.
// Нумерация начинается с 1. Формат n: string: . Обратите внимание на двоеточие и пробел между ними.
// Примеры: (Ввод -> Выход)
// [] --> []
// ["a", "b", "c"] --> ["1: a", "2: b", "3: c"]

var numberStr = (array) => {
    return array.map((e, i) => `${i + 1}: ${e}`)
}

// console.log(numberStr(["a", "b", "c"]));

// # =============================================================================================================================================
// На этот раз ни истории, ни теории. В примерах ниже показано, как написать функцию accum:
// Примеры:
// accum("abcd")        ->   "A-Bb-Ccc-Dddd"
// accum("RqaEzty")     ->   "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
// accum("cwAt")        ->   "C-Ww-Aaa-Tttt"

function accum(s) {
    let str = '';
    for (let i = 0; i < s.length; i++) {
        str += s[i].toUpperCase()
        for (let k = 0; k < i; k++) {
            str += s[i].toLowerCase();
        }
        if (i !== s.length - 1) {
            str += '-'
        }
    }
    return str
}

//console.log(accum("abcd"));
//console.log(accum("RqaEzty"));
//console.log(accum("cwAt"));

// решение других 
function accum1(s) {
    return s.split('').map((c, i) => (c.toUpperCase() + c.toLowerCase().repeat(i))).join('-');
}
function accum2(s) {
    return s.split('').map((x, index) => x.toUpperCase() + Array(index + 1).join(x.toLowerCase())).join('-');
}

// # =============================================================================================================================================
// Ваша задача — создать две функции (max и min или максимум и минимум и т. д., в зависимости от языка), которые получают на вход список целых
// чисел и возвращают наибольшее и наименьшее число из этого списка соответственно.
// Примеры (Ввод -> Выход)
// [4,6,2,1,9,63,-134,566]              ->      max = 566, min = -134
// [-52, 56, 30, 29, -54, 0, -110]      ->      min = -110, max = 56
// [42, 54, 65, 87, 0]                  ->      min = 0, max = 87
// [5]                                  ->      min = 5, max = 5

var min = function (list) {
    return Math.min(...list);
}
var max = function (list) {
    return Math.max(...list)
}

// Тут мне захотелось сделать сортировку массива без различных методов используя цикл

// от большего к меньшему
function cs1(arr) {
    const newArr = [];
    const length = arr.length;
    for (let i = 0; i < length; i++) {
        const max = Math.max(...arr)
        const index = arr.indexOf(max)
        const cut = arr.splice(index, 1)
        newArr.push(...cut)
    }
    console.log(`массив от большего к меньшему: ${newArr}`);
    return newArr
}

// от меньшего к большему
function cs2(arr) {
    const newArr = [];
    const length = arr.length;
    for (let i = 0; i < length; i++) {
        const min = Math.min(...arr)
        const index = arr.indexOf(min)
        const cut = arr.splice(index, 1)
        newArr.push(...cut)
    }
    console.log(`массив от меньшего к большему : ${newArr}`);
    return newArr
}

function cs3(arr) {
    const length = arr.length;
    const forMaxArr = [...arr];
    const forMinArr = [...arr];
    const MaxToMin = [];
    const MinToMax = [];
    for (let i = 0; i < length; i++) {
        const max = Math.max(...forMaxArr)
        const index = forMaxArr.indexOf(max)
        const cut = forMaxArr.splice(index, 1)
        MaxToMin.push(...cut)
    }
    for (let i = 0; i < length; i++) {
        const min = Math.min(...forMinArr)
        const index = forMinArr.indexOf(min)
        const cut = forMinArr.splice(index, 1)
        MinToMax.push(...cut)
    }
    return [MaxToMin, MinToMax]
}


// console.log(cs1([84, 9, 12, 41, 26, 63, -134, 566, -2, -53]));
// console.log(cs2([84, 9, 12, 41, 26, 63, -134, 566, -2, -53]));

// # =============================================================================================================================================
// Заказчику нужен быстрый способ вычисления объема куба с тремя значениями: длиной, шириной и высотой куба. 
// Напишите функцию, которая поможет Заказчику выполнить эти вычисления.

//  *   Формула объема куба:
//  ^       V = a3

// ?    V - объем куба
// ?    a - длина грани куба


function getVolumeOfCuboid(length, width, height) {
    return length * width * height;
}
// console.log(getVolumeOfCuboid(1, 2, 2));    // ==>  4
// console.log(getVolumeOfCuboid(6, 2, 5));    // ==>  60

// # =============================================================================================================================================
// Ваша задача — создать функцию, которая может принимать в качестве аргумента любое неотрицательное целое число и возвращать его с цифрами в
// порядке убывания. По сути, переставьте цифры, чтобы получить максимально возможное число.
// Примеры:
// - Ввод: 42145        Вывод: 54421
// - Ввод: 145263       Вывод: 654321
// - Ввод: 123456789    Вывод: 987654321
function descendingOrder(n) {
    const a = String(n)
    const b = a.split('')
    const c = b.map((e) => Number(e))
    const d = c.sort((a, b) => b - a)
    const e = d.join('')
    const f = Number(e)
    return f
}

function descendingOrder1(n) {
    const a = String(n).split('').map(e => Number(e)).sort((a, b) => b - a).join('')
    return Number(a)
}
// console.log(descendingOrder(123456789));
// console.log(descendingOrder(145263));
// console.log(descendingOrder(1021));

// Решения других
function descendingOrder2(n) {
    return parseInt(String(n).split('').sort().reverse().join(''))
}
function descendingOrder3(n) {
    return parseInt(n.toString().split("").sort().reverse().join(""));
}
// # =============================================================================================================================================
// Тимми и Сара думают, что влюблены, но будут ли они вместе, они узнают об этом только тогда, когда сорвут каждый по цветку.
// Если у одного цветка четное количество лепестков, а у другого нечетное, это означает, что они влюблены. 

// Напишите функцию, которая будет принимать количество лепестков каждого цветка и возвращать true, если они влюблены, и false, если нет.
function lovefunc(flower1, flower2) {
    if (flower1 % 2 === 1 && flower2 % 2 === 0 || flower1 % 2 === 0 && flower2 % 2 === 1) {
        return true
    } else {
        return false
    }
}
// console.log(lovefunc(1, 4));    // ==>  true
// console.log(lovefunc(2, 2));    // ==>  false
// console.log(lovefunc(0, 1));    // ==>  true
// console.log(lovefunc(0, 0));    // ==>  false

// Решения других
function lovefunc1(flower1, flower2) {
    return flower1 % 2 !== flower2 % 2;
}
// # =============================================================================================================================================
// Просто, учитывая строку слов, верните длину самого короткого слова (слов). 
// Строка никогда не будет пустой, и вам не нужно учитывать разные типы данных.
function findShort(s) {
    const a = s.split(' ').map((e) => e.length)
    const b = Math.min(...a)
    return b
}

// Решение в котором возвращаем слово самое короткое
function findShort2(s) {
    const a = s.split(' ')
    const b = a.map((e) => e.length)
    const c = Math.min(...b)
    const d = b.indexOf(c)
    return a[d]
}

// console.log(findShort("bitcoin take over the world maybe who knows perhaps"));                  // ==>  3
// console.log(findShort("turns out random test cases are easier than writing out basic ones"));   // ==>  3
// console.log(findShort("Let's travel abroad shall we"));                                         // ==>  2  


// Решения других
function findShort1(s) {
    return Math.min(...s.split(" ").map(s => s.length));
}

// # =============================================================================================================================================
// Вы пишете код для управления светофорами вашего города.
// Вам нужна функция для обработки каждого изменения с зеленого на желтый, на красный, а затем снова на зеленый.
// Завершите функцию, которая принимает строку в качестве аргумента, представляющую текущее состояние источника света,
// и возвращает строку, представляющую состояние, в которое должен перейти источник света. Например, если вход зеленый, выход должен быть желтым.
function updateLight(current) {
    const obj = {
        green: "yellow",
        yellow: "red",
        red: "green"
    }
    for (const key in obj) {
        if (key === current) {
            return obj[key]
        }
    }
}

// console.log(updateLight("green"));          // ==>      "yellow"
// console.log(updateLight("yellow"));         // ==>      "red"
// console.log(updateLight("red"));            // ==>      "green"

// Решения других
const updateLight2 = (current) => {
    return {
        red: 'green',
        yellow: 'red',
        green: 'yellow'
    }[current];
}

// Решения других с помощью switch
function updateLight3(current) {
    switch (current) {
        case 'green':
            return 'yellow';
        case 'yellow':
            return 'red';
        default:
            return 'green';
    }
}
// # =============================================================================================================================================
// Создайте функцию, которая возвращает массив целых чисел от N до 1, где N > 0.
// Пример: n = 5 --> [5,4,3,2,1]
const reverseSeq = n => {
    const arr = [];
    const length = n;
    for (let i = 0; i < length; i++) {
        arr.push(n--)
    }
    return arr;
};

// Решения других БОЛЕЕЕ ЕФФЕКТИВНОЕ
const reverseSeq1 = n => {
    let arr = [];
    for (let i = n; i > 0; i--) {
        arr.push(i);
    }
    return arr;
};

// console.log(reverseSeq(5));        // [5, 4, 3, 2, 1]
// # =============================================================================================================================================
// Учитывая массив целых чисел, ваше решение должно найти наименьшее целое число. 
// Например: Учитывая [34, 15, 88, 2], ваше решение вернет 2 Учитывая [34, -345, -1, 100], ваше решение вернет -345.
// Для целей этого ката вы можете предположить, что предоставленный массив не будет пустым.
function findSmallestInt(args) {
    return Math.min(...args)
}
// console.log(findSmallestInt([78, 56, 232, 12, 8]));


// # =============================================================================================================================================
// Учитывая строку, вы должны вернуть строку, в которой каждый символ (с учетом регистра) повторяется один раз.
// Примеры (Ввод -> Выход):
// "String"         ->   "SSttrriinngg"
// "Hello World"    ->   "HHeelllloo  WWoorrlldd"
// "1234!_ "        ->   "11223344!!__  "
function doubleChar(str) {
    let string = '';
    for (let i = 0; i < str.length; i++) {
        string += str[i] + str[i]
    }
    return string
}
// console.log(doubleChar("abcd"));        // ==>  aabbccdd
// console.log(doubleChar("Adidas"));      // ==>  AAddiiddaass



// # =============================================================================================================================================
// Создайте функцию, которая выдает персонализированное приветствие. 
// Эта функция принимает два параметра: имя и владельца. 

// Используйте условные выражения, чтобы вернуть правильное сообщение:
//              case	                    return
//          имя равно владельцу         'Hello boss'
//          в противном случае	        'Hello guest'

function greet(name, owner) {
    if (name === owner) {
        return 'Hello boss'
    } else {
        return 'Hello guest'
    }
}
// console.log(greet('Daniel', 'Daniel'));   // ==>    'Hello boss'
// console.log(greet('Greg', 'Daniel'));     // ==>    'Hello guest'


// Решения других Сокращенное
function greet1(name, owner) {
    return name === owner ? 'Hello boss' : 'Hello guest';
}


// # =============================================================================================================================================
// Преобразовать число в перевернутый массив цифр
// Учитывая случайное неотрицательное число, вам необходимо вернуть цифры этого числа в массиве в обратном порядке.
// Пример (Ввод => Выход):
// 35231 => [1,3,2,5,3] 
// 0 => [0]

function digitize(n) {
    return String(n).split('').reverse().map(Number)    // интересный метод map, где в функции опущенны стрелка и параметры для преобразование типа 
    return String(n).split('').reverse().map(e => Number(e)) // мое решение
}
// console.log(digitize(35231));        [ 1, 3, 2, 5, 3 ]


function digitize1(n) {
    return String(n).split('').map(Number).reverse()
}
// # =============================================================================================================================================
// На фабрике принтер печатает этикетки для коробок. Для одного вида коробок принтеру приходится использовать цвета, которые для простоты
// называются буквами от a до m.
// Цвета, используемые принтером, записываются в управляющую строку. Например, «хорошая» управляющая строка будет aaabbbbhaijjjm означать,
// что принтер трижды использовал цвет a, четыре раза цвет b, один раз цвет h, затем один раз цвет a...
// Иногда возникают проблемы: отсутствие цветов, техническая неисправность и выдается "плохая" управляющая строка,
// например, aaaxbbbbyyhwawiwjjjwwm с буквами не из a до m.
// Вам нужно написать функцию printer_error, которая по заданной строке будет возвращать частоту ошибок принтера в виде строки , представляющей
// рациональное число, числитель которого — это количество ошибок, а знаменатель — длина управляющей строки. Не сводите эту дробь к более простому
// выражению. Строка имеет длину большую или равную единице и содержит только буквы от aдо z.

// Примеры:
// s="aaabbbbhaijjjm"
// printer_error(s) => "0/14"

// s="aaaxbbbbyyhwawiwjjjwwm"
// printer_error(s) => "8/22"

s = "aaaxbbbbyyhwawiwjjjwwm"
function printerError(s) {

}
// console.log(printerError(s));

// # =============================================================================================================================================
// Учитывая строку, вам необходимо постепенно объединить первую букву слева и первую букву справа и «1», затем вторую букву слева и вторую букву
// справа и «2» и так далее. Если длина строки нечетная, отбросьте центральный элемент.
// Например:
// charConcat("abcdef")     ==  'af1be2cd3'
// charConcat("abc def")    ==  'af1be2cd3' // same result
// charConcat("CodeWars")   ==  'Cs1or2da3eW4' // same result

function charConcat(string) {
    const arr = [];
    const a = string.split('')
    for (let i = 1; i <= string.length / 2; i++) {
        arr.push(...a.splice(0, 1))
        arr.push(...a.splice(-1, 1))
        arr.push(i)
        // if (a.length === 0) {
        //     return arr.join('')
        // }
    }
    return arr.join('')
}

// if (a.indexOf(' ')) {
//     a.splice(a.indexOf(' '), 1)
// }
// console.log(charConcat("CodeWars"));                // Cs1or2da3eW4
// console.log(charConcat("abc def"));                 // af1be2cd3
// console.log(charConcat("CodeWars Rocks"));          // Cs1ok2dc3eo4WR5a 6rs7
// # =============================================================================================================================================
// Ваша задача — создать функцию, выполняющую четыре основные математические операции. 
// Функция должна принимать три аргумента — операция(строка/символ), значение1(число), значение2(число). 
//  Функция должна возвращать результат чисел после применения выбранной операции. 
// Примеры (Оператор, значение1, значение2) --> вывод 
// ('+', 4, 7) --> 11 
// ('-', 15, 18) --> -3 
// ('*', 5, 5) --> 25 
// ('/', 49, 7) --> 7

function basicOp1(operation, value1, value2) {
    return (operation === '+') ? value1 + value2
        : (operation === '-') ? value1 - value2
            : (operation === '/') ? value1 / value2
                : (operation === '*') ? value1 * value2
                    : 'not found'
}

// #  фантастика
function basicOp(operation, value1, value2) {
    return {
        '+': value1 + value2,
        '-': value1 - value2,
        '/': value1 / value2,
        '*': value1 * value2
    }[operation];
}


// console.log(basicOp('+', 4, 7));    // ==> 11
// console.log(basicOp('-', 15, 18));    // ==> -3
// console.log(basicOp('*', 5, 5));    // ==> 25
// console.log(basicOp('/', 49, 7));    // ==> 7
// # =============================================================================================================================================
// Напишите функцию которая получает два параметра. Первый параметр, «employed», имеет значение true, когда вы работаете, а второй параметр, 
// «vacation», истинен, когда вы находитесь в отпуске.
// Функция должна возвращать значение true, если вы работаете, а не в отпуске (поскольку именно при таких обстоятельствах вам необходимо
// установить будильник). В противном случае он должен вернуть false.

// Примеры:
// ! employed | vacation
// ! трудоустроенный | отпуск
// ? true     | true     => false
// ? true     | false    => true
// ? false    | true     => false
// ? false    | false    => false

function setAlarm1(employed, vacation) {
    if (employed && vacation || employed === false && vacation || employed === false && vacation === false) {
        return false
    } else {
        return true
    }
}
function setAlarm2(employed, vacation) {
    return employed && vacation || employed === false && vacation || employed === false && vacation === false ? false : true
}


// решение других ВПЕЧАТЛЯЕТ
function setAlarm(employed, vacation) {
    return employed && !vacation;
}

// console.log(setAlarm(true, true));      // ==>  false
// console.log(setAlarm(false, true));     // ==>  false
// console.log(setAlarm(true, false));     // ==>  true

// ! =============================================================================================================================================
// ^ Краткое содержание
// В этой ката вам нужно создать функцию с именем uglify_word( uglifyWordв Java и Javascript). Он принимает строковый параметр.
// ^ Что делает uglify_word?
// Он проверяет символ в заданной строке спереди с помощью итерации, на итерации он выполняет следующие шаги:
// ? 1. Флаг есть и он будет запускаться из 1.
// ? 2. Проверьте текущий символ в индексе итерации.
// * Если это символ алфавита [a-zA-Z]и значение флага равно 1, измените этот символ на верхний регистр.
// * Если это символ алфавита [a-zA-Z]и значение флага равно 0, измените этот символ на нижний регистр.
// * В противном случае, если это не символ алфавита, установите значение флага 1.
// ? 3. Если текущий символ является символом алфавита, выполните логическую операцию not над флагом.
// После завершения итерации верните фиксированную строку, которая могла быть изменена в такой итерации.

// Примеры:
// uglify_word("aaa") === "AaA"
// uglify_word("AAA") === "AaA"
// uglify_word("BbB") === "BbB"
// uglify_word("aaa-bbb-ccc") === "AaA-BbB-CcC"
// uglify_word("AaA-BbB-CcC") === "AaA-BbB-CcC"
// uglify_word("eeee-ffff-gggg") === "EeEe-FfFf-GgGg"
// uglify_word("EeEe-FfFf-GgGg") === "EeEe-FfFf-GgGg"
// uglify_word("qwe123asdf456zxc") === "QwE123AsDf456ZxC"
// uglify_word("Hello World") === "HeLlO WoRlD"
function uglifyWord(s) {
    // return s.split('').map((e, i) => (i % 2 === 0) ? e.toUpperCase() : e.toLowerCase()).join('')
    return s.toLowerCase().split('').map((e, i) =>
        (e === '-' || e === ' ') ? '*'
            : (i % 2 === 0) ? e.toUpperCase()
                : (i % 2 === 1) ? e.toLowerCase()
                    : e.toLowerCase()
    ).join('')
}

// (i % 2 === 0 || e === '-' || e === ' ') ? e.toUpperCase()

function uglifyWord1(s) {
    return s.split('').map((e, i) => (i % 2 === 0) ? e.toUpperCase() : e.toLowerCase()).join('')
}

// console.log(uglifyWord("AAA"));                     // ==>  "AaA"
// console.log(uglifyWord("aaa-bbb-ccc"));             // ==>  "AaA-BbB-CcC"
// console.log(uglifyWord("qwe123asdf456zxc"));        // ==>  "QwE123AsDf456ZxC"
// console.log(uglifyWord("EeEe-FfFf-GgGg"));          // ==>  "EeEe-FfFf-GgGg"
// console.log(uglifyWord("eeee-ffff-gggg"));          // ==>  "EeEe-FfFf-GgGg"
// console.log(uglifyWord("Hello World"));          // ==>  "EeEe-FfFf-GgGg"
// # =============================================================================================================================================
// В этом простом задании вам дано число, и вы должны сделать его отрицательным. Но, может быть, число уже отрицательное? 
// Примеры 
// - makeNegative(1);    // return -1
// - makeNegative(-5);   // return -5
// - makeNegative(0);    // return 0
// - makeNegative(0.12); // return -0.12
// Примечания:
// Число уже может быть отрицательным, и в этом случае никаких изменений не требуется. Ноль (0) не проверяется на наличие какого-либо
// конкретного знака. Отрицательные нули не имеют математического смысла.

function makeNegative(num) {
    return (num < 0) ? num : -num
}
// console.log(makeNegative(42));
// console.log(makeNegative(-2));
// console.log(makeNegative(-5));
// console.log(makeNegative(34));
// # =============================================================================================================================================
//  * indexOf в JavaScript не работает с массивами в качестве входных данных. Это связано с тем, что [1,2] === [1,2] вернет false в JavaScript.
//  * Многие другие языки имеют схожие особенности.

//  * Однако иногда бывает полезно найти массив. Напишите функцию, которая ищет массив внутри двумерного массива и возвращает индекс первого
//  * совпадающего элемента. Если совпадения нет, ваша функция должна вернуть -1.
// См. несколько примеров:
// ? - var arrayToSearch = [[1,2],[3,4],[5,6]];
// ? - var query = [1,2];                           // => 0
// ? - query = [5,6];                               // => 2
// ? - query = [9,2];                               // => -1

// * Вам необходимо будет проверить введенные данные по следующим критериям:
// ? 1. каждый элемент искомого массива должен быть массивом;
// ? 2. каждый подмассив в двумерном массиве должен иметь длину два;
// ? 3. запрос должен представлять собой массив длиной два.

// ! Если входные данные недействительны, вы должны выдать ошибку.
// : См. несколько примеров:
// ? - var arrayToSearch = [[1,2],[3,4],[5,6],[7,8,9]];     // => throw Error
// ? - arrayToSearch = [1,2,3,4,5,6];                       // => throw Error
// ? - arrayToSearch = [[1,2],[3,4],[5,6]];                 // => valid input
// ? - var query = [1,2];                                   // => valid input
// ? - query = 5;                                           // => throw Error
// ? - query = [9,2,1];                                     // => throw Error

const bigArray = [[2, 3], [7, 2], [9, 20], [1, 2], [7, 2], [45, 4], [7, 87], [4, 5], [2, 7], [6, 32]];
const searchFor = [45, 4];

const searchArray = (arrayToSearch, query) => {
    if (arrayToSearch.some(e => e.length !== 2) || query.length !== 2) {
        throw Error()
    } else {
        for (let i = 0; i < arrayToSearch.length; i++) {
            if (query[0] === arrayToSearch[i][0] && query[1] === arrayToSearch[i][1]) {
                return i
            }
        }
    }
    return -1
}
// console.log(searchArray(bigArray, searchFor));
// # =============================================================================================================================================

// # =============================================================================================================================================
//  Напишите функцию RemoveExclamationMarks, которая удаляет все восклицательные знаки из заданной строки.
function removeExclamationMarks(s) {
    return s.split('').filter((e) => e !== '!').join('');
}
// console.log(removeExclamationMarks("H!e!l!l!o W!o!r!l!d!"));

// решение других, более короткое, разбивает строку в массив по указанному в параметре разделителю
function removeExclamationMarks1(s) {
    return s.split('!').join('');
}
// # =============================================================================================================================================
// Вам дан массив из n+1 целых чисел от 1 до n. Кроме того, существует одно повторяющееся целое число. Массив не отсортирован.
// Примером допустимого массива может быть [3, 2, 5, 1, 3, 4]. Он имеет целые числа от 1 до 5, а число 3 дублируется. [1, 2, 4, 5, 5]
// недействительны, поскольку отсутствует 3. Вы должны вернуть повторяющееся значение как одно целое число.
// нужно найти только одно число
function findDup(arr) {
    const sort = arr.sort((a, b) => a - b)
    for (let i = 0; i < sort.length; i++) {
        if (sort[i] === sort[i + 1]) {
            return sort[i]
        }
    }
}
// console.log(findDup([1, 2, 2, 3]));                     // ==> 2
// console.log(findDup([1, 3, 2, 5, 4, 15, 7, 6, 5,]));    // ==> 5
// # =============================================================================================================================================
// ВЫСОКОСТНЫЙ ГОДЫ
// В этом ката вам нужно просто определить, является ли данный год високосным или нет.
// Если вы не знаете правил, вот они:
// - Годы, кратные 4, являются високосными,
// - Годы, кратные 100, не являются високосными,
// - Годы, делящиеся на 400, являются високосными.
// - Годы тестирования находятся в диапазоне 1600 ≤ год ≤ 4000.
function isLeapYear(year) {
    if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
        return true
    } else {
        return false
    }
}

// сокращение
function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
}
// console.log(isLeapYear(2000)); // ==> true
// console.log(isLeapYear(2020)); // ==> true
// console.log(isLeapYear(2015)); // ==> false
// console.log(isLeapYear(2100)); // ==> false
// # =============================================================================================================================================
// Представьте, что вы начинаете с 5-го этажа здания, затем спускаетесь на 2-й этаж, а затем снова поднимаетесь на 8-й этаж. Вы проехали в
// общей сложности 3 + 6 = 9 этажей расстояния. Учитывая массив, представляющий ряд этажей, на которые вы должны подняться на лифте, 
// верните целое число, представляющее общее расстояние, пройденное для посещения каждого этажа в массиве по порядку.
// простые примеры
// - elevatorDistance([5,2,8]) = 9
// - elevatorDistance([1,2,3]) = 2
// - elevatorDistance([7,1,7,1]) = 18

// если два последовательных этажа одинаковы,
// пройденное расстояние между ними равно 0
// - elevatorDistance([3,3]) = 0

// Массив всегда будет содержать как минимум 2 этажа. Случайные тесты будут содержать от 2 до 20 элементов в массиве и минимальные значения от 0 до 30.


function elevatorDistance1(array) {
    let x = 0;
    for (let i = 0; i < array.length; i++) {
        if (i !== array.length - 1) {
            if (array[i] > array[i + 1]) {
                x = x + (array[i] - array[i + 1])
            } else {
                x = x + (array[i + 1] - array[i])
            }
        } else {
            return x
        }
    }
}

function elevatorDistance(array) {
    let distance = 0;
    for (let i = 0; i < array.length; i++) {
        if (i !== array.length - 1) {
            if (array[i] > array[i + 1]) {
                distance = distance + (array[i] - array[i + 1])
            } else {
                distance = distance + (array[i + 1] - array[i])
            }
        } else {
            return distance
        }
    }
}


// console.log(elevatorDistance([5, 2, 8]));        // 9
// console.log(elevatorDistance([1, 2, 3]));        // 2
// console.log(elevatorDistance([7, 1, 7, 1]));        // 18


// # =============================================================================================================================================
// Функция подсчета пройденных метров с переводом в метры

function calcKm(...m) {
    const arrMetrs = [];
    const metrs = m.reduce((a, i) => a + i);
    arrMetrs.push(metrs)
    if (metrs % 1000 === 0) {
        return `${metrs / 1000}km`
    } else {
        return `${Math.round(metrs / 1000)}km ${metrs % 1000}m`
    }
}

// console.log(calcKm(1500, 500, 100));
// console.log(calcKm(400, 500, 100));

// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================
// # =============================================================================================================================================


